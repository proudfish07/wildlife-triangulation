<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wildlife Triangulation Tool</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 60vh; }
    .input-panel { padding: 1rem; }
    .input-panel textarea { width: 100%; height: 100px; }
    .input-panel button { margin-top: 0.5rem; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    th, td { padding: 0.5rem; border: 1px solid #ccc; text-align: center; }
  </style>
</head>
<body>
  <div class="input-panel">
    <h2>輸入觀測點（每行：緯度, 經度, 方位角）</h2>
    <textarea id="input" placeholder="例如：\n23.5,121,0\n23.6,121.1,270"></textarea>
    <button onclick="processInput()">進行定位</button>
    <div id="pointTable"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([23.5, 121], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    // 修正：使 0° 為正北，順時針方向，Leaflet 使用經度為 x，緯度為 y
    function bearingToRadians(b) {
      return (90 - b) * Math.PI / 180;
    }

    function lineFromPointBearing(lat, lon, bearing) {
      const angle = bearingToRadians(bearing);
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      return { x: lon, y: lat, dx, dy, lat, lon, bearing };
    }

    function getIntersection(line1, line2) {
      const { x: x1, y: y1, dx: dx1, dy: dy1 } = line1;
      const { x: x2, y: y2, dx: dx2, dy: dy2 } = line2;
      const det = dx1 * dy2 - dy1 * dx2;
      if (Math.abs(det) < 1e-10) return null;
      const t = ((x2 - x1) * dy2 - (y2 - y1) * dx2) / det;
      return [y1 + dy1 * t, x1 + dx1 * t];
    }

    function processInput() {
      map.eachLayer(layer => {
        if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
      });

      const input = document.getElementById('input').value.trim().split('\n');
      const lines = [];

      let tableHtml = '<table><tr><th>#</th><th>緯度</th><th>經度</th><th>方位角</th></tr>';

      input.forEach((line, idx) => {
        const [lat, lon, bearing] = line.split(',').map(Number);
        const point = lineFromPointBearing(lat, lon, bearing);
        lines.push(point);

        const marker = L.marker([lat, lon]).addTo(map).bindPopup(`觀測點 ${idx + 1}<br>方位角: ${bearing}°<br>座標: ${lat.toFixed(5)}, ${lon.toFixed(5)}`);
        const endLat = lat + point.dy * 0.1;
        const endLon = lon + point.dx * 0.1;
        L.polyline([[lat, lon], [endLat, endLon]], { color: 'red' }).addTo(map);

        tableHtml += `<tr><td>${idx + 1}</td><td>${lat.toFixed(5)}</td><td>${lon.toFixed(5)}</td><td>${bearing}°</td></tr>`;
      });

      tableHtml += '</table>';
      document.getElementById('pointTable').innerHTML = tableHtml;

      let intersections = [];
      for (let i = 0; i < lines.length; i++) {
        for (let j = i + 1; j < lines.length; j++) {
          const inter = getIntersection(lines[i], lines[j]);
          if (inter) intersections.push(inter);
        }
      }

      if (intersections.length > 0) {
        const avgLat = intersections.reduce((sum, p) => sum + p[0], 0) / intersections.length;
        const avgLon = intersections.reduce((sum, p) => sum + p[1], 0) / intersections.length;
        L.marker([avgLat, avgLon], { color: 'blue' }).addTo(map)
          .bindPopup(`預測位置<br>座標: ${avgLat.toFixed(5)}, ${avgLon.toFixed(5)}`).openPopup();
        map.setView([avgLat, avgLon], 13);
      }
    }
  </script>
</body>
</html>
