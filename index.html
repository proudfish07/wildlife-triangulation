<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wildlife Triangulation Tool</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 60vh; }
    .input-panel { padding: 1rem; }
    .input-panel textarea { width: 100%; height: 100px; }
    .input-panel button { margin: 0.5rem 0.5rem 0.5rem 0; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    th, td { padding: 0.5rem; border: 1px solid #ccc; text-align: center; }
  </style>
</head>
<body>
  <div class="input-panel">
    <h2>觀測記錄與定位</h2>
    <button onclick="recordPoint()">記錄觀測點</button>
    <button onclick="clearAllData()">清除所有資料</button>
    <button onclick="saveInputData()">保存資料</button>
    <textarea 
      id="input"
      placeholder="每行格式：日期,時間,緯度,經度,方位角,gain,強度&#10;例如: 2025-06-11,08:45:00,23.50000,121.00000,40,15,80"></textarea>
    <button onclick="processInput()">從輸入資料定位</button>
    <button onclick="shareLocation()">分享預測位置</button>
    <div id="pointTable"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([23.5, 121], 7);
    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data: &copy; OpenTopoMap (CC-BY-SA)',
      maxZoom: 17
    }).addTo(map);

    let recordedPoints = [];
    let currentPrediction = null;
    let currentLocationMarker = null;

    function savePointsToStorage() {
      localStorage.setItem('wildlife_points', JSON.stringify(recordedPoints));
    }

    function loadPointsFromStorage() {
      const data = localStorage.getItem('wildlife_points');
      if (data) {
        try {
          recordedPoints = JSON.parse(data);
          updateInputArea();
        } catch (e) {
          recordedPoints = [];
        }
      }
    }

    function clearAllData() {
      if (confirm('確定要清除所有資料嗎？此動作無法還原。')) {
        recordedPoints = [];
        localStorage.removeItem('wildlife_points');
        document.getElementById('input').value = '';
        document.getElementById('pointTable').innerHTML = '';
        map.eachLayer(layer => {
          if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
        });
        currentPrediction = null;
        // 重新顯示目前位置
        showCurrentLocationOnMap();
      }
    }

    function bearingToRadians(b) {
      return ((-b + 90 + 360) % 360) * Math.PI / 180;
    }

    function lineFromPointBearing(lat, lon, bearing) {
      const angle = bearingToRadians(bearing);
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      return { x: lon, y: lat, dx, dy, lat, lon, bearing };
    }

    function getIntersection(line1, line2) {
      const { x: x1, y: y1, dx: dx1, dy: dy1 } = line1;
      const { x: x2, y: y2, dx: dx2, dy: dy2 } = line2;
      const det = dx1 * dy2 - dy1 * dx2;
      if (Math.abs(det) < 1e-10) return null;
      const t = ((x2 - x1) * dy2 - (y2 - y1) * dx2) / det;
      return [y1 + dy1 * t, x1 + dx1 * t];
    }

    function updateInputArea() {
      // 以目前的recordedPoints組成textarea內容
      const lines = recordedPoints.map(p => {
        // 日期,時間,緯度,經度,方位角,gain,強度
        const date = p.date || '';
        const time = p.time || '';
        const lat = (typeof p.lat === 'number') ? p.lat.toFixed(5) : '';
        const lon = (typeof p.lon === 'number') ? p.lon.toFixed(5) : '';
        const bearing = (p.bearing !== null && p.bearing !== undefined) ? p.bearing : '';
        const gain = (p.gain !== null && p.gain !== undefined) ? p.gain : '';
        const strength = (p.strength !== null && p.strength !== undefined) ? p.strength : '';
        return [date, time, lat, lon, bearing, gain, strength].join(',');
      });
      document.getElementById('input').value = lines.join('\n');
      savePointsToStorage();
    }

    function displayPointsAndCalculate(lines) {
      map.eachLayer(layer => {
        if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
      });

      // 重新顯示目前位置
      showCurrentLocationOnMap();

      let tableHtml = '<table><tr><th>#</th><th>日期</th><th>時間</th><th>緯度</th><th>經度</th><th>方位角</th><th>Gain</th><th>強度</th></tr>';

      // only lines with lat/lon/bearing will be used for定位
      const validLines = [];

      lines.forEach((point, idx) => {
        const { date, time, lat, lon, bearing, gain, strength } = point;
        if (typeof lat === "number" && typeof lon === "number" && typeof bearing === "number" && !isNaN(lat) && !isNaN(lon) && !isNaN(bearing)) {
          validLines.push(lineFromPointBearing(lat, lon, bearing));
          const marker = L.marker([lat, lon]).addTo(map).bindPopup(
            `觀測點 ${idx + 1}<br>日期: ${date || ''}<br>時間: ${time || ''}<br>方位角: ${bearing}°<br>座標: ${lat}, ${lon}<br>Gain: ${gain || ''}<br>強度: ${strength || ''}`
          );
          const endLat = lat + Math.cos(bearingToRadians(bearing)) * 0.1;
          const endLon = lon + Math.sin(bearingToRadians(bearing)) * 0.1;
          L.polyline([[lat, lon], [endLat, endLon]], { color: 'red' }).addTo(map);
        }
        tableHtml += `<tr>
          <td>${idx + 1}</td>
          <td>${date || ''}</td>
          <td>${time || ''}</td>
          <td>${lat !== undefined ? lat : ''}</td>
          <td>${lon !== undefined ? lon : ''}</td>
          <td>${bearing !== undefined && bearing !== null ? bearing : ''}</td>
          <td>${gain !== undefined && gain !== null ? gain : ''}</td>
          <td>${strength !== undefined && strength !== null ? strength : ''}</td>
        </tr>`;
      });

      tableHtml += '</table>';
      document.getElementById('pointTable').innerHTML = tableHtml;

      let intersections = [];
      for (let i = 0; i < validLines.length; i++) {
        for (let j = i + 1; j < validLines.length; j++) {
          const inter = getIntersection(validLines[i], validLines[j]);
          if (inter) intersections.push(inter);
        }
      }

      if (intersections.length > 0) {
        const avgLat = intersections.reduce((sum, p) => sum + p[0], 0) / intersections.length;
        const avgLon = intersections.reduce((sum, p) => sum + p[1], 0) / intersections.length;
        currentPrediction = { lat: avgLat, lon: avgLon };
        L.marker([avgLat, avgLon], { color: 'blue' }).addTo(map)
          .bindPopup(`預測位置<br>座標: ${avgLat.toFixed(5)}, ${avgLon.toFixed(5)}`).openPopup();
        map.setView([avgLat, avgLon], 13);
      } else {
        currentPrediction = null;
      }
    }

    function processInput() {
      const input = document.getElementById('input').value.trim().split('\n');
      // 允許格式為: 日期,時間,緯度,經度,方位角,gain,強度
      recordedPoints = input.map(line => {
        const [date, time, lat, lon, bearing, gain, strength] = line.split(',');
        return {
          date: date ? date.trim() : '',
          time: time ? time.trim() : '',
          lat: lat !== undefined && lat !== '' ? Number(lat) : null,
          lon: lon !== undefined && lon !== '' ? Number(lon) : null,
          bearing: bearing !== undefined && bearing !== '' ? Number(bearing) : null,
          gain: gain !== undefined && gain !== '' ? Number(gain) : null,
          strength: strength !== undefined && strength !== '' ? Number(strength) : null
        };
      });
      savePointsToStorage();
      displayPointsAndCalculate(recordedPoints);
    }

    function saveInputData() {
      // 跟 processInput 一樣，但不會立即定位，只保存
      const input = document.getElementById('input').value.trim().split('\n');
      recordedPoints = input.map(line => {
        const [date, time, lat, lon, bearing, gain, strength] = line.split(',');
        return {
          date: date ? date.trim() : '',
          time: time ? time.trim() : '',
          lat: lat !== undefined && lat !== '' ? Number(lat) : null,
          lon: lon !== undefined && lon !== '' ? Number(lon) : null,
          bearing: bearing !== undefined && bearing !== '' ? Number(bearing) : null,
          gain: gain !== undefined && gain !== '' ? Number(gain) : null,
          strength: strength !== undefined && strength !== '' ? Number(strength) : null
        };
      });
      savePointsToStorage();
      updateInputArea(); // 以規範格式回填
      alert('資料已保存！');
    }

    function recordPoint() {
      if (!navigator.geolocation) {
        alert('裝置不支援定位');
        return;
      }
      navigator.geolocation.getCurrentPosition(pos => {
        const now = new Date();
        const pad = n => n < 10 ? '0' + n : n;
        const date = now.getFullYear() + '-' + pad(now.getMonth() + 1) + '-' + pad(now.getDate());
        const time = pad(now.getHours()) + ':' + pad(now.getMinutes()) + ':' + pad(now.getSeconds());
        recordedPoints.push({
          date: date,
          time: time,
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
          bearing: null,
          gain: null,
          strength: null
        });
        updateInputArea();
        savePointsToStorage();
        alert(`已記錄座標：\n日期: ${date}\n時間: ${time}\n緯度: ${pos.coords.latitude.toFixed(5)}, 經度: ${pos.coords.longitude.toFixed(5)}\n請至下方手動輸入方位角、gain、強度`);
        showCurrentLocationOnMap(pos.coords.latitude, pos.coords.longitude);
      }, () => alert('無法取得定位資訊'));
    }

    function shareLocation() {
      if (!recordedPoints.length) {
        alert('沒有觀測資料可分享');
        return;
      }

      // 組裝分享內容
      let text = '';
      text += '【野生動物三角定位觀測紀錄】\n';
      text += '觀測資料（日期,時間,緯度,經度,方位角,gain,強度）：\n';
      recordedPoints.forEach((p, i) => {
        text += `${i+1}. ${p.date || ''},${p.time || ''},${(typeof p.lat === 'number' ? p.lat : '')},${(typeof p.lon === 'number' ? p.lon : '')},${(p.bearing !== null && p.bearing !== undefined ? p.bearing : '')},${(p.gain !== null && p.gain !== undefined ? p.gain : '')},${(p.strength !== null && p.strength !== undefined ? p.strength : '')}\n`;
      });
      if (currentPrediction) {
        text += `\n預測位置：\n緯度: ${currentPrediction.lat.toFixed(5)}, 經度: ${currentPrediction.lon.toFixed(5)}\n`;
      }
      text += `\n網址：${location.href}`;

      if (navigator.share) {
        navigator.share({
          title: '野生動物預測位置',
          text,
          url: location.href
        }).catch(err => console.error('分享失敗', err));
      } else {
        prompt('請手動複製以下資訊分享：', text);
      }
    }

    // 顯示目前位置在地圖上的標記
    function showCurrentLocationOnMap(lat=null, lon=null) {
      // 若未指定則嘗試取得
      if (lat === null || lon === null) {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            showCurrentLocationOnMap(pos.coords.latitude, pos.coords.longitude);
          });
        }
        return;
      }
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
      }
      currentLocationMarker = L.marker([lat, lon], {
        icon: L.icon({
          iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
        })
      }).addTo(map).bindPopup("你現在的位置").openPopup();
    }

    // textarea 變動自動保存
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('input').addEventListener('input', function() {
        saveInputData();
      });
    });

    // 頁面載入自動載入資料與自動定位
    window.onload = function () {
      loadPointsFromStorage();
      showCurrentLocationOnMap();
      // 若第一次進入頁面，且沒有觀測資料，自動記錄目前位置
      if (recordedPoints.length === 0 && navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          const now = new Date();
          const pad = n => n < 10 ? '0' + n : n;
          const date = now.getFullYear() + '-' + pad(now.getMonth() + 1) + '-' + pad(now.getDate());
          const time = pad(now.getHours()) + ':' + pad(now.getMinutes()) + ':' + pad(now.getSeconds());
          recordedPoints.push({
            date: date,
            time: time,
            lat: pos.coords.latitude,
            lon: pos.coords.longitude,
            bearing: null,
            gain: null,
            strength: null
          });
          updateInputArea();
          savePointsToStorage();
          alert(`已自動記錄目前座標：\n日期: ${date}\n時間: ${time}\n緯度: ${pos.coords.latitude.toFixed(5)}, 經度: ${pos.coords.longitude.toFixed(5)}\n請至下方手動輸入方位角、gain、強度`);
          showCurrentLocationOnMap(pos.coords.latitude, pos.coords.longitude);
        });
      }
    };

  </script>
</body>
</html>
