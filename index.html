<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>é‡ç”Ÿå‹•ç‰©è¿½è¹¤å®šä½ç³»çµ±</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root { --primary: #2c3e50; --accent: #d35400; --bg: #ecf0f1; }
    body { margin: 0; font-family: -apple-system, sans-serif; background: var(--bg); display: flex; flex-direction: column; height: 100vh; }
    #map { height: 35vh; width: 100%; shrink: 0; z-index: 1; border-bottom: 2px solid #ccc; }
    .content { flex: 1; overflow-y: auto; padding: 12px; padding-bottom: 120px; }
    
    .subject-card { 
      background: white; border-radius: 12px; padding: 15px; margin-bottom: 25px; 
      box-shadow: 0 4px 10px rgba(0,0,0,0.1); border-top: 8px solid var(--subject-color); 
      position: relative; 
    }
    
    .subject-id-input { font-size: 1.3rem; font-weight: bold; border: none; width: 70%; color: var(--subject-color); outline: none; background: transparent; border-bottom: 1px dashed #ccc; }
    .obs-item { background: #fdfdfd; border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-top: 10px; position: relative; }
    .input-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }
    label { font-size: 0.7rem; color: #95a5a6; display: block; margin-bottom: 2px; }
    input { width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 5px; box-sizing: border-box; font-size: 0.95rem; }
    
    button { padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 0.9rem; }
    .btn-compass { background: #34495e; color: white; width: 45px; height: 38px; display: flex; align-items: center; justify-content: center; border-radius: 5px; }
    .btn-calc { background: var(--subject-color); color: white; flex: 1; opacity: 0.9; }
    .btn-share { background: #2980b9; color: white; flex: 1; }
    
    .action-bar { position: fixed; bottom: 0; width: 100%; background: white; padding: 12px; display: flex; gap: 10px; box-shadow: 0 -3px 15px rgba(0,0,0,0.1); box-sizing: border-box; z-index: 1000; }
    .prediction-box { background: #f0f0f0; color: var(--subject-color); padding: 10px; border-radius: 8px; margin: 10px 0; font-weight: bold; border: 2px solid var(--subject-color); }
    
    .bearing-indicator { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }

    #compassModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; color: white; flex-direction: column; align-items: center; justify-content: center; }
    .compass-disc { width: 180px; height: 180px; border: 3px solid white; border-radius: 50%; position: relative; margin: 20px; }
  </style>
</head>
<body>

<div id="map"></div>
<div class="content" id="subjectContainer"></div>

<div class="action-bar">
  <button style="flex: 2; background: var(--primary); color: white;" onclick="addNewSubject()">â• æ–°å¢ç—…ä¾‹</button>
  <button style="flex: 1; background: #95a5a6; color: white;" onclick="resetAll()">é‡è¨­</button>
</div>

<div id="compassModal">
  <h3>æ–¹ä½è®€å– (çœŸåŒ—è£œæ­£)</h3>
  <div class="compass-disc" id="compassDisc"><div style="position:absolute; top:0; left:50%; width:2px; height:100%; background:white; transform:translateX(-50%);"></div></div>
  <h2 id="liveAngle" style="font-size: 3rem; margin: 10px 0;">0Â°</h2>
  <div style="font-size: 0.8rem; margin-bottom: 5px;">ç£åè§’æ ¡æ­£ï¼š</div>
  <input type="number" id="manualDeclination" value="-4.5" step="0.1" style="width:80px; text-align:center;" onchange="updateDeclination(this.value)">
  <button onclick="lockCompass()" style="background:var(--accent); color:white; padding:15px 50px; border-radius:30px; margin-top:20px;">é–å®šè§’åº¦</button>
  <button onclick="closeCompass()" style="background:none; color:white; margin-top:10px;">å–æ¶ˆ</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let subjects = JSON.parse(localStorage.getItem('tracking_v11')) || [];
  let currentTarget = { sIdx: null, pIdx: null };
  let rawAngle = 0;
  let declination = -4.5;

  const getBearingColor = (angle) => `hsl(${angle % 360}, 80%, 50%)`;
  const getSubjectColor = (index) => `hsl(${(index * 137.5) % 360}, 65%, 40%)`;

  const map = L.map('map').setView([23.5, 121], 7);
  L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17 }).addTo(map);

  function save() { localStorage.setItem('tracking_v11', JSON.stringify(subjects)); updateMapDisplay(); }

  // è‡ªå‹•æŠ“å–ç£åè§’é‚è¼¯ (æ ¹æ“šåº§æ¨™)
  function getAutoDeclination(lat, lon) {
    if(!lat || !lon) return -4.5;
    // å°ç£æ±éƒ¨ WMM2025/26 ç°¡æ˜“ç·šæ€§æ’å€¼
    // å°æ±ç´„ -5.0, èŠ±è“®ç´„ -4.8
    if(lat > 24) return -4.7;
    if(lat < 23) return -5.1;
    return -4.9;
  }

  function addNewSubject() {
    subjects.push({ 
      id: Date.now(), 
      subjectId: 'å€‹é«” ' + (subjects.length + 1), 
      color: getSubjectColor(subjects.length),
      points: [createPoint(), createPoint()], 
      prediction: null 
    });
    render();
  }

  function createPoint() {
    const now = new Date();
    return { 
      date: now.toISOString().split('T')[0], 
      time: now.toTimeString().split(' ')[0].substring(0, 5), 
      lat: '', lon: '', bearing: '', gain: '', strength: '', note: '' 
    };
  }

  function render() {
    const container = document.getElementById('subjectContainer');
    container.innerHTML = '';
    subjects.forEach((s, sIdx) => {
      const card = document.createElement('div');
      card.className = 'subject-card';
      card.style.setProperty('--subject-color', s.color);
      card.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <input class="subject-id-input" style="color:${s.color}" value="${s.subjectId}" onchange="subjects[${sIdx}].subjectId=this.value;save();">
            <button onclick="delSub(${sIdx})" style="background:none; color:#e74c3c; font-size:0.75rem;">åˆªé™¤å€‹é«”</button>
        </div>
        ${s.points.map((p, pIdx) => `
          <div class="obs-item">
            <div class="input-row">
              <div><label>ç·¯åº¦</label><input type="number" step="any" value="${p.lat}" onchange="upd(${sIdx},${pIdx},'lat',this.value)"></div>
              <div><label>ç¶“åº¦</label><input type="number" step="any" value="${p.lon}" onchange="upd(${sIdx},${pIdx},'lon',this.value)"></div>
            </div>
            <button style="width:100%; margin-bottom:8px; background:#eee; padding:5px; font-size:0.7rem;" onclick="getGPS(${sIdx},${pIdx})">ğŸ“ å¡«å…¥ GPS</button>
            <div class="input-row">
              <div style="display:flex; gap:5px; grid-column:span 2; align-items:flex-end;">
                <div style="flex:1;">
                  <label><span class="bearing-indicator" style="background:${p.bearing ? getBearingColor(p.bearing) : '#ccc'}"></span>æ–¹ä½è§’(çœŸåŒ—Â°)</label>
                  <input type="number" value="${p.bearing}" onchange="upd(${sIdx},${pIdx},'bearing',this.value)">
                </div>
                <button class="btn-compass" onclick="openCompass(${sIdx},${pIdx})">ğŸ§­</button>
              </div>
            </div>
            <div class="input-row" style="margin-top:8px;">
              <div><label>Gain</label><input type="text" value="${p.gain}" onchange="upd(${sIdx},${pIdx},'gain',this.value)"></div>
              <div><label>å¼·åº¦</label><input type="text" value="${p.strength}" onchange="upd(${sIdx},${pIdx},'strength',this.value)"></div>
            </div>
            <label style="margin-top:5px;">å‚™è¨»</label><input type="text" value="${p.note}" onchange="upd(${sIdx},${pIdx},'note',this.value)">
          </div>
        `).join('')}
        <button class="btn-add-pt" style="margin:10px 0; width:100%; border:1px dashed #ccc; background:none; border-radius:8px; padding:10px;" onclick="subjects[${sIdx}].points.push(createPoint());render();">ï¼‹ æ–°å¢å®šä½ç·š</button>
        ${s.prediction ? `<div class="prediction-box">ğŸ¯ é æ¸¬ä½ç½®ï¼š${s.prediction.lat}, ${s.prediction.lon}</div>` : ''}
        <div style="display:flex; gap:10px;">
          <button class="btn-calc" onclick="calculate(${sIdx})">ğŸ“ è¨ˆç®—å®šä½</button>
          <button class="btn-share" onclick="share(${sIdx})">ğŸ“¤ åˆ†äº«å ±å‘Š</button>
        </div>
      `;
      container.appendChild(card);
    });
    save();
  }

  function updateMapDisplay() {
    map.eachLayer(l => { if(l instanceof L.Marker || l instanceof L.Polyline || l instanceof L.CircleMarker) map.removeLayer(l); });
    subjects.forEach(s => {
      const sColor = s.color || '#333';
      s.points.forEach(p => {
        if(p.lat && p.lon) {
          L.circleMarker([p.lat, p.lon], {radius: 6, color: sColor, fillColor: sColor, fillOpacity: 0.6}).addTo(map);
          if(p.bearing !== '') {
            const bColor = getBearingColor(p.bearing);
            const rad = (90 - p.bearing) * Math.PI / 180;
            const end = [parseFloat(p.lat) + Math.sin(rad)*0.03, parseFloat(p.lon) + Math.cos(rad)*0.03];
            L.polyline([[p.lat, p.lon], end], {color: bColor, weight: 3, dashArray: '5, 8', opacity: 0.8}).addTo(map);
          }
        }
      });
      if(s.prediction) {
        L.marker([s.prediction.lat, s.prediction.lon]).addTo(map).bindPopup(s.subjectId).openPopup();
      }
    });
  }

  async function openCompass(sIdx, pIdx) {
    currentTarget = { sIdx, pIdx };
    const p = subjects[sIdx].points[pIdx];
    // è‡ªå‹•æŠ“å–ç£åè§’
    declination = getAutoDeclination(p.lat, p.lon);
    document.getElementById('manualDeclination').value = declination;

    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      const permission = await DeviceOrientationEvent.requestPermission();
      if (permission !== 'granted') return alert("éœ€æ¬Šé™");
    }
    document.getElementById('compassModal').style.display = 'flex';
    window.addEventListener('deviceorientationabsolute', handleOrientation, true);
  }

  function handleOrientation(event) {
    let heading = event.webkitCompassHeading || (360 - event.alpha);
    if (heading) {
      rawAngle = heading;
      let corrected = (rawAngle + declination + 360) % 360;
      document.getElementById('liveAngle').innerText = Math.round(corrected) + "Â°";
      document.getElementById('compassDisc').style.transform = `rotate(${-corrected}deg)`;
    }
  }

  function updateDeclination(val) { declination = parseFloat(val); }
  function lockCompass() {
    let corrected = (rawAngle + declination + 360) % 360;
    upd(currentTarget.sIdx, currentTarget.pIdx, 'bearing', Math.round(corrected));
    closeCompass(); render();
  }
  function closeCompass() {
    document.getElementById('compassModal').style.display = 'none';
    window.removeEventListener('deviceorientationabsolute', handleOrientation);
  }

  function upd(sIdx, pIdx, key, val) { subjects[sIdx].points[pIdx][key] = val; save(); }
  function delSub(sIdx) { if(confirm("åˆªé™¤æ­¤è¨˜éŒ„ï¼Ÿ")) { subjects.splice(sIdx,1); render(); } }
  
  function getGPS(sIdx, pIdx) { 
    navigator.geolocation.getCurrentPosition(pos => {
      subjects[sIdx].points[pIdx].lat = pos.coords.latitude.toFixed(6);
      subjects[sIdx].points[pIdx].lon = pos.coords.longitude.toFixed(6);
      // è‡ªå‹•æ›´æ–°ç£åè§’é è¨­å€¼
      declination = getAutoDeclination(pos.coords.latitude, pos.coords.longitude);
      render();
    }, err => alert("ç„¡æ³•å–å¾—ä½ç½®"), {enableHighAccuracy: true}); 
  }

  function calculate(sIdx) {
    const s = subjects[sIdx];
    const lines = s.points.filter(p => p.lat && p.lon && p.bearing !== '').map(p => {
      const rad = (90 - p.bearing) * Math.PI / 180;
      return { x: parseFloat(p.lon), y: parseFloat(p.lat), dx: Math.cos(rad), dy: Math.sin(rad) };
    });
    if (lines.length < 2) return alert("è‡³å°‘éœ€å…©æ¢æ–¹ä½ç·š");
    let inters = [];
    for (let i = 0; i < lines.length; i++) {
      for (let j = i + 1; j < lines.length; j++) {
        const l1 = lines[i], l2 = lines[j];
        const det = l1.dx * (-l2.dy) - (-l1.dy) * l2.dx;
        if (Math.abs(det) > 1e-10) {
          const t = ((l2.x - l1.x) * (-l2.dy) - (l2.y - l1.y) * l2.dx) / det;
          inters.push([l1.y + l1.dy * t, l1.x + l1.dx * t]);
        }
      }
    }
    if (inters.length > 0) {
      s.prediction = { 
        lat: (inters.reduce((a, b) => a + b[0], 0) / inters.length).toFixed(6), 
        lon: (inters.reduce((a, b) => a + b[1], 0) / inters.length).toFixed(6) 
      };
      render(); map.setView([s.prediction.lat, s.prediction.lon], 15);
    }
  }

  function share(idx) {
    const s = subjects[idx];
    let t = `ã€é‡ç”Ÿå‹•ç‰©ä¸‰è§’å®šä½è§€æ¸¬ç´€éŒ„ã€‘\n`;
    t += `å€‹é«”ç·¨è™Ÿï¼š${s.subjectId}\n\n`;
    t += `è§€æ¸¬è³‡æ–™ï¼ˆæ—¥æœŸ,æ™‚é–“,ç·¯åº¦,ç¶“åº¦,æ–¹ä½è§’,gain,å¼·åº¦ï¼‰ï¼š\n`;
    
    s.points.forEach((p, i) => {
      t += `${i+1}. ${p.date},${p.time},${p.lat},${p.lon},${p.bearing},${p.gain},${p.strength}\n`;
    });

    if(s.prediction) {
      t += `\né æ¸¬ä½ç½®ï¼š\nç·¯åº¦: ${s.prediction.lat}, ç¶“åº¦: ${s.prediction.lon}\n`;
      t += `Googleåœ°åœ–ï¼šhttps://www.google.com/maps?q=${s.prediction.lat},${s.prediction.lon}`;
    }

    if (navigator.share) {
      navigator.share({ title: 'è¿½è¹¤å ±å‘Š', text: t }).catch(err => copyToClipboard(t));
    } else {
      copyToClipboard(t);
      alert("å·²è¤‡è£½å ±å‘Šå…§å®¹è‡³å‰ªè²¼ç°¿ï¼");
    }
  }

  function copyToClipboard(text) {
    const el = document.createElement('textarea');
    el.value = text;
    document.body.appendChild(el);
    el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
  }

  function resetAll() { if(confirm("ç¢ºå®šé‡è¨­æ‰€æœ‰è³‡æ–™ï¼Ÿ")) { localStorage.clear(); location.reload(); } }
  window.onload = render;
</script>
</body>
</html>
